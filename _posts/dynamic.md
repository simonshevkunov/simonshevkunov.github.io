<span style="color: #E5E4E4; font-family: Helvetica;">

### [Алгоритмы](README.md) / Динамическое программирование

# **Динамическое программирование**

Нередко на олимпиадах встречаются задачи, провоцирующие использовать алгоритмы перебора. Но простой перебор может быть неоптимален, поэтому для решения таких задач используется метод *динамического программирования*. Этот метод заключается в разбиении сложной задачи на менее сложные подзадачи. Предполагается, что у нас есть таблица, куда мы запоминаем решения подзадач, при том, что нам известны самые начальные значения (например, нулевой элемент в таблице). 

Самый яркий способ демонстрации работы метода динамического программирования – поиск n-ого числа в ряду Фибоначчи по заданному *n*. 

Для справки: любое число в последовательности Фибоначчи – сумма двух предыдущих ему чисел в последовательности. Первые два числа ряда – единицы. 

Перед написанием кода выведем формулу нахождения *n*-ого числа Фибоначчи. Нетрудно понять, что $Fn = Fn - 1 + Fn – 2$. 

Таким образом решение можно представить ввдие таблицы, где *i*-той ячейке преписывается решение задачи, в которой *n* = *i*.

| $n$ | 1 | 2 | 3 | 4 | 5 | 6 | ... |
|-----|---|---|---|---|---|---|-----|
| $Fn$ | 1 | 1 | 2 | 3 | 5 | 8 | ... | 

Теперь мы можем записать это решение несложной рекурсией. Чтобы реализовать действие метода, нужно создать таблицу. Роль таблицы в данном случае сыграет словарь, его необходимо завести как глобальную переменную (вне функции): 

    memory = {}

Чтобы рекурсия не ушла в бесконечность, мы занесем в словарь изначально известные значения первых двух чисел Фибоначчи – эти значения будут «тормозить» рекурсию. Это две решенные подзадачи.

    memory = {1: 1, 2: 1}

В нашем словаре ключи – значения, которые будет принимать $n$, а значения к ключам – ячейки в таблице, которые по ходу выполнения функции будут заполняться. 

Теперь можно приступить к написанию функции, которая будет принимать на вход единственное число *n*. С самого начала нужно написать проверку, которая будет возвращать значение по ключу *n*, если такой ключ уже есть в словаре. Это условие также поможет не уйти в бесконечную рекурсию. Более подробное пояснение приведу ниже. 

    memory = {1: 1, 2: 1}

    def fib(n):
        if n in memory:
            return memory[n]
 
Дальше мы опишем действия функции, если элемента по ключу $n$ в словаре нет. В этом случае нужно записать в словарь значение для ключа *n*, то есть `fib(n - 1) + fib(n - 2)`, и вернуть это значение. 

    memory = {1: 1, 2: 1}

    def fib(n):
        if n in memory:
            return memory[n]
        else:
            memory[n] = fib(n - 1) + fib(n - 2)
            return memory[n]

Так почему эта функция вернет верный ответ? Если $n$ не равно 1 или 2, то начнет выполняться `else`, и функция будет искать значение для $n – 1$, затем для $n – 2$, $n – 3$ и так до тех пор, пока функция не «упрется» в изначально записанные решения для позадач. Тогда функция вернет 1 и поднимется на уровень выше – $F3$ , для него запишет в словарь и вернет значение $F1 + F2 = 2$, поднимется еще на уровень выше и так далее до того, как не найдется значение для $n – 1$. Затем функция сразу же вернет значение для $n – 2$, так как это значение уже было записано в словарь при подсчете `fib(n – 1)`.

Задача с поиском числа Фибоначчи довольно проста, поэтому ее решение несложно записать и без рекурсии:

    memory = [0 for _ in range(n)]
    memory[0] = 1

    for i in range(1, n):
        memory[i] = memory[i - 1] + memory[i - 2]
        
    print(memory[n - 1]) 

В данном случае в качестве таблицы выступает массив длины $n$, а $n - 1$-ый элемент – $n$-ое число в ряду Фибоначчи (нумерация начинается с нуля). Достаточно задать первоначальное значение только нулевому элементу, так как в рамках этого решения второе число можно вывести по формуле (получится сумма нулевого элемента, который равен 1, и -1-ого – последнего, который равен 0). Так как нулевой элемент известен, $i$ будет принимать значения с 1 до $n – 1$, и $i$-му элементу в массиве будет присваиваться значение суммы $i – 1$-го и $i – 2$-го элементов. Обратиться к $n$-му числу Фибоначчи можно будет по индексу $n – 1$. 

Я не могу точно сказать какой метод решения лучше: с рекурсией или с циклом. Тут, так сказать, каждый выбирает «на свой вкус». Рекурсия интуитивно понятна, но ее надо использовать осторожно, чтобы не написать бесконечную рекурсию (обязательно записывать данные в таблицу и изменять аргументы, чтобы в конце концов рекурсия дошла до начальных значений). Для написания цикла не надо следить за уходом в бесконечность, но тут надо тоже быть аккуратным, чтобы не спровоцировать ошибку `list index out of range`. В словарях же за индексацией следить не нужно. При этом оба решения работают за *O*$(n)$.
