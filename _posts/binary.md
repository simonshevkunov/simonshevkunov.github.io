<span style="color: #E5E4E4; font-family: Helvetica;">

### [Алгоритмы](README.md) / Бинарный поиск

# **Бинарный поиск**

Дима загадал Паше некое число от 1 до 100, и задача Паши – отгадать это число как можно быстрее. Паша говорит Диме число, а Дима говорит, больше ли, меньше или равно названное число загаданному. Паша может пробовать все числа от 1 до 100 – 1, 2, 3, 4… но это долго. Немного подумав, Паша нашел оптимальный способ. 

Он спросил число $50$. Дима ответил: “Мало”. Паша обрадовался, пусть он не угадал с первой попытки, но он уже забраковал половину всех чисел. Дальше он назвал число 75 – “Много”. Паша отсек еще четверть чисел. Теперь он назовет число 63 – “Много”. Следующая догадка – 57 – “Угадал”.

Паша воспользовался алгоритмом бинарного поиска. Скорее всего, вы догадались, как он работает:

Мы проводим поиск элемента в отсортированном (это условие обязательно) массиве, при этом мы знаем его правую и левую границу (если представить, что массив записан в строку от меньшего элемента к большему). 

Мы сравниваем наш элемент с центральным элементом в между правой и левой границей. Если центральный элемент больше искомого, мы присваиваем правой границе индекс центрального элемента, если меньше – центральный элемент присваивается левой границе. Так мы делаем до тех пор, пока центральный между двумя границами элемент не будет равен искомому или пока границы не совпадут (они совпадут и с центральным, и с искомым элементом). Когда элемент найдет, его индекс можно обработать (вернуть `True`, сам индекс и т. д.)

В плане реализации алгоритм также несложный:

    def binary_search(massive, item):
        # задаем правые и левые границы 
        # изначально они совпадают с первым и последним индексом массива
        left = 0
        right = len(massive) - 1
        
        while left <= right:
            # находим середину
            middle = (right + left) // 2
            if massive[middle] == item:
                # обрабатываем значение (возвращаем место в массиве)
                return middle
            elif massive[middle] > item:
                right = middle
            else:
                left = middle

Этот алгоритм работает за *O*$(\log n)$ операций, в то время как линейный поиск (перебор всех элементов массива) работает за *O*$(n)$ в худшем случае (если искомый элемент окажется последним). Чтобы не быть голословным, я попробую оба алгоритма на практике.

Есть два алгоритма, случайный массив и случайно выбранный элемент. Для начала сгенерируем массив на 100 элементов и засечем реальное время работы  для каждого алгоритма.

    binary search result -  61
    dumb search result -  61
    binary search execution time -  4.1962e-05
    dumb search execution time -  8.345e-06

Линейный поиск сработал за 0,000008345 секунды, а бинарный – за 0,00004162 секунды. Линейный однозначно справился быстрее, что не удивительно, понадобилась только 61 операция. Да и разница небольшая – стотысячные доли секунды. Но стоит изменить длину массива до $10^7$ и картина сразу поменяется:

    binary search result -  7677643
    dumb search result -  7677643
    binary search execution time -  5.0068e-05
    dumb search execution time -  1.224620104

Время работы бинарного поиска увеличилось лишь на стотысячную долю секунды, в то время как перебор работает больше, чем за секунду (неудивительно – ему понадобилось выполнить $7 \times 10^6$ операций), для большинства соревнований это очень медленно. 
