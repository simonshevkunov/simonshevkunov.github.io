<span style="color: #E5E4E4; font-family: Helvetica;">

### [Алгоритмы](README.md) / Проверка числа на простоту

# **Проверка числа на простоту**

Как можно проверить число на простоту? Очевидно – если у числа нет делителей больше единицы и меньше самого числа, то оно простое. Значит, надо перебрать числа до *n*, и если оно поделится хотя бы на одно из них, то число окажется составным.

    def prime(n):
        '''
        Перебираем с двух, т. к. на 0 нельзя делить, а на 1 поделится любое число,
        до n - 1, т. к. любое число делится само на себя.
        '''
        for i in range(2, n):
            if n % i == 0:
                return False
        return True

Конечно, этот алгоритм сработает и будет возвращать правильные ответы. Но насколько быстро? Очевидно, что за *O(n)* операций, но если *n* окажется большим числом, например 10 ^ 9 + 7? Как оптимизировать этот алгоритм?

Оптимизация в данном случае проста. Понятно, что если мы рассматриваем число 24, нам не нужно проверять делимость на 23, 22, 21, 20 и так далее. Наибольший делитель числа 24  – 12, то есть ½. надо ли все проверять до *½n*? Можно еще быстрее.

Выпишем все возможные разложения 24 на два множителя, начиная с 2:

2 * 12

3 * 8

4 * 6

6 * 4

8 * 3

12 * 2

Мы видим, что после какого-то момента произведения начинают повторяться. И даже отчасти понятно когда. Для большего понимания рассмотрим еще один пример – 36:

2 * 18

3 * 12

4 * 9

6 * 6

9 * 4

12 * 3

Теперь стало ясно, что произведения повторяются после $ \sqrt{n} $. Это и есть та самая граница, до которой нужно перебирать делители:


    def prime(n):
        ’’’
        Корень из числа – это число в степени 1/2.
        Лучше прибавить 1 и сделать на 1 операцию больше, т. к. int() округляет вниз.
        ’’’
        for i in range(2, int(n ** 0.5) + 1):
            if n % i == 0:
                return False
        return True
